I have this in my angular app
import { NgFor } from '@angular/common';
import { Component, ElementRef, OnInit, ViewChildren, QueryList, HostListener } from '@angular/core';
import { Record } from '../../models/record';

@Component({
  selector: 'app-waveform-4',
  standalone: true,
  imports: [NgFor],
  templateUrl: './waveform-4.component.html',
  styleUrl: './waveform-4.component.css'
})
export class Waveform4Component {
  @ViewChildren('waveCanvas') waveCanvases!: QueryList<ElementRef<HTMLCanvasElement>>;

  data: Record[] = [
    { id: 0, name: 'James Wilson', phoneNumber: '09195544661',audio:'assets/2.mp3' },
    { id: 1, name: 'Jane Smith', phoneNumber: '09195544661',audio:'assets/3.mp3' },
    { id: 2, name: 'Emily Johnson', phoneNumber: '09195544661',audio:'assets/4.mp3'},
    { id: 3, name: 'Michael Brown', phoneNumber: '09195544661',audio:'assets/5.mp3'},
    { id: 4, name: 'Olivia Davis', phoneNumber: '09195544661',audio:'assets/6.mp3' },
    { id: 5, name: 'William Martinez', phoneNumber: '09195544661',audio:'assets/7.mp3' },
    { id: 6, name: 'Ava Garcia', phoneNumber: '09195544661',audio:'assets/8.mp3'},
    { id: 7, name: 'James Wilson', phoneNumber: '09195544661',audio:'assets/9.mp3'},
  ];

  private audioContext!: AudioContext;
  private audioBuffers: Map<number, AudioBuffer> = new Map();
  private sources: Map<number, AudioBufferSourceNode | null> = new Map();
  isPlaying: Map<number, boolean> = new Map();
  audioUrls: string[] = ['assets/2.mp3', 'assets/3.mp3', 'assets/4.mp3','assets/5.mp3','assets/6.mp3','assets/7.mp3','assets/8.mp3' ,'assets/9.mp3'];
  private playheadPositions: Map<number, number> = new Map();
  private startOffsets: Map<number, number> = new Map();
  private startTimes: Map<number, number> = new Map();
  private updateIntervals: Map<number, any> = new Map();
  lastIndex : number = 0;

  constructor() {}

  ngOnInit(): void {
    this.audioContext = new AudioContext();
  }

  ngAfterViewInit(): void {
    this.loadAndDrawWaveforms();
  }

  async loadAndDrawWaveforms(): Promise<void> {
    for (let i = 0; i < this.audioUrls.length; i++) {
      try {
        const response = await fetch(this.audioUrls[i]);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        this.audioBuffers.set(i, audioBuffer);

        const canvas = this.waveCanvases.toArray()[i].nativeElement;
        this.drawWaveform(i, 0);
      } catch (error) {
        console.error('Error loading or decoding audio:', error);
      }
    }
  }

  drawWaveform(index: number, playheadPosition: number = 0): void {
    const canvas = this.waveCanvases.toArray()[index].nativeElement;
    const canvasCtx = canvas.getContext('2d')!;
    const { width, height } = canvas;

    if (!this.audioBuffers.has(index)) {
      console.error('Audio buffer is not loaded for index:', index);
      return;
    }

    const audioBuffer = this.audioBuffers.get(index)!;
    const channelData = audioBuffer.getChannelData(0);
    const step = Math.ceil(channelData.length / width);
    const amp = height / 2;

    canvasCtx.clearRect(0, 0, width, height);
    canvasCtx.fillStyle = 'rgb(200, 200, 200)';
    canvasCtx.fillRect(0, 0, width, height);
    canvasCtx.lineWidth = 2;
    canvasCtx.strokeStyle = '#39943c';
    canvasCtx.beginPath();

    for (let i = 0; i < width; i++) {
      const min = Math.min(...channelData.slice(i * step, (i + 1) * step));
      const max = Math.max(...channelData.slice(i * step, (i + 1) * step));
      canvasCtx.moveTo(i, (1 + min) * amp);
      canvasCtx.lineTo(i, (1 + max) * amp);
    }

    canvasCtx.stroke();

    const playheadX = playheadPosition * width / audioBuffer.duration;
    canvasCtx.strokeStyle = 'red';
    canvasCtx.lineWidth = 2;
    canvasCtx.beginPath();
    canvasCtx.moveTo(playheadX, 0);
    canvasCtx.lineTo(playheadX, height);
    canvasCtx.stroke();
  }

  @HostListener('mousedown', ['$event'])
  onMouseDown(event: MouseEvent): void {
    this.setPlayheadPosition(event);
  }

  @HostListener('mousemove', ['$event'])
  onMouseMove(event: MouseEvent): void {
    if (event.buttons === 1) { // Left mouse button is down
      this.setPlayheadPosition(event);
    }
  }

  @HostListener('mouseup')
  onMouseUp(): void {
    // Optional: Handle mouse up if needed
  }

  setPlayheadPosition(event: MouseEvent): void {
    const canvasIndex = this.getCanvasIndexFromEvent(event);
    if (canvasIndex === null) return;

    const canvas = this.waveCanvases.toArray()[canvasIndex].nativeElement;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const canvasWidth = canvas.clientWidth;
    const playheadPosition = Math.max(0, Math.min(this.audioBuffers.get(canvasIndex)!.duration, x / canvasWidth * this.audioBuffers.get(canvasIndex)!.duration));
    this.playheadPositions.set(canvasIndex, playheadPosition);
    this.drawWaveform(canvasIndex, playheadPosition);

    if (this.isPlaying.get(canvasIndex)) {
      this.stopAudio(canvasIndex);
      this.playAudio(canvasIndex);
    }
  }

  playPauseAudio(index: number): void {
    if (this.isPlaying.get(index)) {
      this.pauseAudio(index);
    } else {
      this.playAudio(index);
    }
  }

  playAudio(index: number): void {
    this.stopAudio(this.lastIndex);
    // this.movePlayhead(this.lastIndex,-36000);
    this.lastIndex=index;
    if (this.sources.get(index)) {
      this.stopAudio(index); // Ensure no previous source is playing
    }
    const audioBuffer = this.audioBuffers.get(index)!;
    const source = this.audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(this.audioContext.destination);

    this.startOffsets.set(index, this.playheadPositions.get(index) || 0);
    this.startTimes.set(index, this.audioContext.currentTime);
    source.start(0, this.startOffsets.get(index)!);

    this.sources.set(index, source);
    this.isPlaying.set(index, true);
    this.startUpdatingPlayhead(index);
  }

  stopAudio(index: number): void {
    const source = this.sources.get(index);
    if (source) {
      source.stop();
      source.disconnect();
      this.sources.set(index, null);
    }
    this.isPlaying.set(index, false);
    this.stopUpdatingPlayhead(index);
  }

  pauseAudio(index: number): void {
    this.stopAudio(index);
  }

  startUpdatingPlayhead(index: number): void {
    this.stopUpdatingPlayhead(index); // Clear any existing interval
    this.updateIntervals.set(index, setInterval(() => {
      if (this.isPlaying.get(index)) {
        const elapsed = this.audioContext.currentTime - (this.startTimes.get(index) ?? 0);
        const newPlayheadPosition = (this.startOffsets.get(index) ?? 0) + elapsed;
        if (newPlayheadPosition >= (this.audioBuffers.get(index)?.duration ?? 0)) {
          this.playheadPositions.set(index, this.audioBuffers.get(index)!.duration);
          this.stopAudio(index);
        } else {
          this.playheadPositions.set(index, newPlayheadPosition);
        }
        this.drawWaveform(index, this.playheadPositions.get(index) || 0);
      }
    }, 100)); // Update every 100 milliseconds
  }

  stopUpdatingPlayhead(index: number): void {
    const interval = this.updateIntervals.get(index);
    if (interval) {
      clearInterval(interval);
      this.updateIntervals.set(index, null);
    }
  }

  getCanvasIndexFromEvent(event: MouseEvent): number | null {
    const canvases = this.waveCanvases.toArray();
    for (let i = 0; i < canvases.length; i++) {
      const canvas = canvases[i].nativeElement;
      const rect = canvas.getBoundingClientRect();
      if (event.clientX >= rect.left && event.clientX <= rect.right &&
          event.clientY >= rect.top && event.clientY <= rect.bottom) {
        return i;
      }
    }
    return null;
  }

  movePlayhead(index: number, seconds: number): void {
    const audioBuffer = this.audioBuffers.get(index);
    if (!audioBuffer) return;

    const currentPlayheadPosition = this.playheadPositions.get(index) || 0;
    const newPlayheadPosition = Math.max(0, Math.min(audioBuffer.duration, currentPlayheadPosition + seconds));

    this.playheadPositions.set(index, newPlayheadPosition);
    this.drawWaveform(index, newPlayheadPosition);

    if (this.isPlaying.get(index)) {
      this.stopAudio(index);
      this.playAudio(index);
    }
  }

  movePlayheadForward(index: number): void {
    this.movePlayhead(index, 5);
  }

  movePlayheadBackward(index: number): void {
    this.movePlayhead(index, -5);
  }


  goNext(index : number){
    this.movePlayhead(index,-36000);
    this.pauseAudio(index);
    this.playAudio(index+1);
  }

  goPrevious(index : number){
    this.movePlayhead(index,-36000);
    this.pauseAudio(index);
    this.playAudio(index-1);
  }

}
------------------
<div id="main" dir="rtl">
    <table>
        <thead>
          <tr>
            <th>شناسه</th>
            <th>نام</th>
            <th>شماره تماس</th>
            <th>صوت</th>
            <th>تنظیمات</th>
          </tr>
        </thead>
        <tbody>
          <tr *ngFor="let d of data">
            <td>{{ d.id }}</td>
            <td>{{ d.name }}</td>
            <td>{{ d.phoneNumber }}</td>
            <td>
                <canvas #waveCanvas></canvas>
            </td>
            <td dir="ltr">
                <img (click)="goPrevious(d.id)" height="35" width="35" src="../../../assets/previous.png">
                <img (click)="movePlayheadBackward(d.id)" height="35" width="35" src="../../../assets/backward.png">
                @if (isPlaying.get(d.id)) {
                    <img (click)="playPauseAudio(d.id)" height="35" width="35" src="../../../assets/pause.jpg">
                }@else{
                    <img (click)="playPauseAudio(d.id)" height="35" width="35" src="../../../assets/play.png">
                }
                <img (click)="movePlayheadForward(d.id)" height="35" width="35" src="../../../assets/forwaard.png">
                <img (click)="goNext(d.id)" height="35" width="35" src="../../../assets/next.png">

            </td>
          </tr>
        </tbody>
      </table>
</div>
